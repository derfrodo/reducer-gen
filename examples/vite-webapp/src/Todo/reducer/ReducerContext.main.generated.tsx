// This file has been generated by reducer-gen (@Stefan Pauka) written in 2020 / 2021 / 2022 / 2023 (times runs ... ;) ).
// DO NOT Change anything inside this file. Every time the generator is used, it will be overwritten.

import React, { useCallback, useEffect, useLayoutEffect, useMemo, useRef, useState } from "react";
import { State } from "./state";
import { todoReducer } from "./reducer/reducer.main.generated";
import { getTodoDefaultState } from "./defaultState.base.generated";
import { TodoReducerActions } from "./reducerActions/reducerActions.main.generated";
import { todoActionCreators } from "./actionCreators/actionCreators.main.generated";
import { TodoStatePropertiesEnum } from "./stateProperties.base.generated";

export type OnTodoReducerContextDispatchWillBeCalled = (action: TodoReducerActions) => void;

export interface ITodoReducerContext {
    state: State;
    dispatch: React.Dispatch<TodoReducerActions>;
    listenOnDispatchWillBeCalled: (callback: OnTodoReducerContextDispatchWillBeCalled) => void;
    removeOnDispatchWillBeCalled: (callback: OnTodoReducerContextDispatchWillBeCalled) => void;
}

export type IDispatchTodoReducerContext = React.Dispatch<TodoReducerActions>;

export type IStateTodoReducerContext = State;

export const TodoReducerContext = React.createContext<ITodoReducerContext>({
    state: getTodoDefaultState(),
    dispatch: () => { throw new Error("Reducer Context TodoReducerContext has not been initialized yet. Did you forget to add a provider to the application as parent node?"); },
    listenOnDispatchWillBeCalled: () => { throw new Error("Reducer Context TodoReducerContext has not been initialized yet. Did you forget to add a provider to the application as parent node?"); },
    removeOnDispatchWillBeCalled: () => { throw new Error("Reducer Context TodoReducerContext has not been initialized yet. Did you forget to add a provider to the application as parent node?"); },
});

export const DispatchTodoReducerContext = React.createContext<IDispatchTodoReducerContext>(() => undefined);

export const StateTodoReducerContext = React.createContext<IStateTodoReducerContext>(getTodoDefaultState());

export const TodoReducerContextProvider = (props: {
    children: React.ReactNode;
    getDefaultState?: typeof getTodoDefaultState;
}) => {
    const { children, getDefaultState } = props;

    const [state, dispatch] = React.useReducer(
        todoReducer,
        undefined,
        getDefaultState ?? getTodoDefaultState
    );

    const dispatchWillBeCalledCallbacks = useRef<
        OnTodoReducerContextDispatchWillBeCalled[]
    >([]);

    const listenOnDispatchWillBeCalled = useCallback(
        (callback: OnTodoReducerContextDispatchWillBeCalled) => {
            if (!dispatchWillBeCalledCallbacks.current) {
                dispatchWillBeCalledCallbacks.current = [callback];
            } else if (
                dispatchWillBeCalledCallbacks.current.filter(
                    (item) => item === callback
                ).length === 0
            ) {
                dispatchWillBeCalledCallbacks.current.push(callback);
            }
        },
        []
    );

    const removeOnDispatchWillBeCalled = useCallback(
        (callback: OnTodoReducerContextDispatchWillBeCalled) => {
            if (!dispatchWillBeCalledCallbacks.current) {
                dispatchWillBeCalledCallbacks.current = [callback];
            } else if (
                dispatchWillBeCalledCallbacks.current.filter(
                    (item) => item === callback
                ).length !== 0
            ) {
                dispatchWillBeCalledCallbacks.current = dispatchWillBeCalledCallbacks.current.filter(
                    (item) => item !== callback
                );
            }
        },
        []
    );

    const dispatchCallback = useCallback<typeof dispatch>((...args) => {
        const callbacks = dispatchWillBeCalledCallbacks.current;
        for (const cb of callbacks || []) {
            cb(args[0]);
        }
        dispatch(...args);
    }, []);

    const context: ITodoReducerContext = React.useMemo(
        () => ({
            state,
            dispatch: dispatchCallback,
            listenOnDispatchWillBeCalled,
            removeOnDispatchWillBeCalled,
        }),
        [
            state,
            dispatchCallback,
            listenOnDispatchWillBeCalled,
            removeOnDispatchWillBeCalled,
        ]
    );

    return (
        <DispatchTodoReducerContext.Provider value={dispatchCallback}>
            <StateTodoReducerContext.Provider value={state}>
                <TodoReducerContext.Provider value={context}>
                    {children}
                </TodoReducerContext.Provider>
            </StateTodoReducerContext.Provider>
        </DispatchTodoReducerContext.Provider>
    );
};
export const useTodoReducerContext: () => ITodoReducerContext = () => {
    return React.useContext<ITodoReducerContext>(TodoReducerContext);
};

export const useTodoReducerContextState: () => IStateTodoReducerContext = () => {
    return React.useContext<IStateTodoReducerContext>(StateTodoReducerContext);
};

export const useTodoReducerContextDispatch: () => IDispatchTodoReducerContext = () => {
    return React.useContext<IDispatchTodoReducerContext>(DispatchTodoReducerContext);
};
/**
 * Use this method if you want to react on dispatch calls (e.g. call additional methods or talk to a... frame?)
 * @param callback callback which will be called dispatch gets called
 */
export const useTodoDispatchWillBeCalledEffect = (callback: OnTodoReducerContextDispatchWillBeCalled) => {
    const {
        listenOnDispatchWillBeCalled,
        removeOnDispatchWillBeCalled,
    } = useTodoReducerContext();

    useEffect(() => {
        if(callback){
            listenOnDispatchWillBeCalled(callback)
            return () => {
                removeOnDispatchWillBeCalled(callback)
            }
        }
    }, [callback, listenOnDispatchWillBeCalled, removeOnDispatchWillBeCalled]);
};

/**
 * Use this method if you want to react on state changes (e.g. call additional methods or talk to a... frame?)
 * @param onStateChanged callback which will be called if TodoState changes
 */
export const useTodoStateChangedEffect = (
    onStateChanged: (next: State, old: State | null) => Promise<void> | void
) => {
    const state = useTodoReducerContextState();

    const callbackRef = useRef<typeof onStateChanged>(onStateChanged);
    const [, setOld] = useState<State | null>(null);

    useEffect(() => {
        callbackRef.current = onStateChanged;
    }, [onStateChanged]);

    useLayoutEffect(() => {
        setOld((prev) => {
            const { current } = callbackRef;
            if (current && state !== prev) {
                current(state, prev);
            }
            return state;
        });
    }, [state]);
};

/**
 * Use this method if you want to react on state changes concerning a specific property
 * @param property property which is to be watched
 * @param onStatePropertyChanged callback which will be called if property in state changes
 */
export const useTodoStatePropertyChangedEffect = <
    TKey extends keyof State
>(
    property: TKey,
    onStatePropertyChanged: (
        next: State[TKey],
        old: State[TKey] | null,
        state: State,
        oldState: State | null
    ) => Promise<void> | void
) => {
    const callbackRef = useRef<typeof onStatePropertyChanged>(
        onStatePropertyChanged
    );

    useEffect(() => {
        callbackRef.current = onStatePropertyChanged;
    }, [onStatePropertyChanged]);

    const changedCallback = useCallback(
        async (next: State, old: State | null) => {
            const cb = callbackRef.current;
            if (cb && (!old || next[property] !== old[property])) {
                await cb(
                    next[property],
                    old !== null ? old[property] : null,
                    next,
                    old
                );
            }
        },
        [property]
    );

    useTodoStateChangedEffect(changedCallback);
};

export type TodoSetPropertyHandler<T extends keyof State> = (next: State[T]) => void;
export type TodoPropertyTuple<T extends keyof State> = [State[T], TodoSetPropertyHandler<T>]

export function useDirectTodoProperty<
    T extends keyof State
>(propertyName: T): T extends "todos" ? TodoPropertyTuple<"todos"> : TodoPropertyTuple<T>;
export function useDirectTodoProperty<
    T extends keyof State
>(propertyName: T): T extends "categories" ? TodoPropertyTuple<"categories"> : TodoPropertyTuple<T>;
export function useDirectTodoProperty<
    T extends keyof State
>(propertyName: T): T extends "undefinableNumbers" ? TodoPropertyTuple<"undefinableNumbers"> : TodoPropertyTuple<T>;
export function useDirectTodoProperty<
    T extends keyof State
>(propertyName: T): T extends "undefinableNumber" ? TodoPropertyTuple<"undefinableNumber"> : TodoPropertyTuple<T>;
export function useDirectTodoProperty<
    T extends keyof State
>(propertyName: T): T extends "currentData" ? TodoPropertyTuple<"currentData"> : TodoPropertyTuple<T>;
export function useDirectTodoProperty<
    T extends keyof State | TodoStatePropertiesEnum
>(propertyName: T): TodoPropertyTuple<T>;

/**
 * Use this method if you want to get a single property from state and a callback function for updating it of Todo
 * @param propertyName property of state
 */
export function useDirectTodoProperty<
    T extends keyof State
>(propertyName: T) {
    const value = useDirectTodoPropertyValue(propertyName);
    const setProperty = useDirectTodoPropertySetProperty(propertyName as any);
    return useMemo(() => [value, setProperty], [value, setProperty]);
};

export function useNamedTodoStateProperty<
    T extends keyof State | TodoStatePropertiesEnum
>(propertyName: T) {
    return useDirectTodoProperty<T>(propertyName);
}

export function useDirectTodoPropertyValue<
    T extends keyof State | TodoStatePropertiesEnum
>(propertyName: T): State[T];

/**
 * Use this method if you want to get only a single property from state of Todo
 * @param propertyName property of state
 */
export function useDirectTodoPropertyValue<
    T extends keyof State
>(propertyName: T): State[T] {
    const state = useTodoReducerContextState();
    return state[propertyName];
};

export function useNamedTodoStatePropertyValue<
    T extends keyof State
>(propertyName: T) {
    return useDirectTodoPropertyValue<T>(propertyName);
}

export function useDirectTodoPropertySetProperty<
    T extends keyof State
>(propertyName: T): T extends "todos" ? TodoSetPropertyHandler<"todos"> : TodoSetPropertyHandler<T>;
export function useDirectTodoPropertySetProperty<
    T extends keyof State
>(propertyName: T): T extends "categories" ? TodoSetPropertyHandler<"categories"> : TodoSetPropertyHandler<T>;
export function useDirectTodoPropertySetProperty<
    T extends keyof State
>(propertyName: T): T extends "undefinableNumbers" ? TodoSetPropertyHandler<"undefinableNumbers"> : TodoSetPropertyHandler<T>;
export function useDirectTodoPropertySetProperty<
    T extends keyof State
>(propertyName: T): T extends "undefinableNumber" ? TodoSetPropertyHandler<"undefinableNumber"> : TodoSetPropertyHandler<T>;
export function useDirectTodoPropertySetProperty<
    T extends keyof State
>(propertyName: T): T extends "currentData" ? TodoSetPropertyHandler<"currentData"> : TodoSetPropertyHandler<T>;

/**
 * Use this method if you want a callback function for updating a single property of Todo
 * @param propertyName property of state
 */
export function useDirectTodoPropertySetProperty<
    T extends keyof State
>(propertyName: T) {
    const dispatch = useTodoReducerContextDispatch();

    return useMemo(() => {
        switch (propertyName) {
            case "todos":
                return (next: State["todos"]) =>
                    dispatch(
                        todoActionCreators.setTodos(
                            next
                        )
                    );
            case "categories":
                return (next: State["categories"]) =>
                    dispatch(
                        todoActionCreators.setCategories(
                            next
                        )
                    );
            case "undefinableNumbers":
                return (next: State["undefinableNumbers"]) =>
                    dispatch(
                        todoActionCreators.setUndefinableNumbers(
                            next
                        )
                    );
            case "undefinableNumber":
                return (next: State["undefinableNumber"]) =>
                    dispatch(
                        todoActionCreators.setUndefinableNumber(
                            next
                        )
                    );
            case "currentData":
                return (next: State["currentData"]) =>
                    dispatch(
                        todoActionCreators.setCurrentData(
                            next
                        )
                    );
            default:
                throw new Error(
                    `Unknown property. No property with name "${propertyName}" has been registered for state of feature "Todo".`
                );
        }
    }, [dispatch, propertyName]);
};
