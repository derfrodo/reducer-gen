
export function isKeyof{{../featureName.pascalCase}}State(propertyName: any): propertyName is keyof State {
    return (
        typeof propertyName === "string" ||
        typeof propertyName === "number" ||
        typeof propertyName === "symbol"
        ) &&
        ({{#each state.properties}}
            propertyName === "{{name}}"{{#unless @last}} ||{{/unless}}{{/each}}
        )
} 

export type {{featureName.pascalCase}}SetPropertyHandler<T extends keyof State> = (next: State[T]) => void;
export type {{featureName.pascalCase}}PropertyTuple<T extends keyof State> = [State[T], {{featureName.pascalCase}}SetPropertyHandler<T>]

{{#each state.properties}}
export function useDirect{{../featureName.pascalCase}}Property<
    T extends keyof {{../state.stateName}}
>(propertyName: T): T extends "{{name}}" ? {{../featureName.pascalCase}}PropertyTuple<"{{name}}"> : {{../featureName.pascalCase}}PropertyTuple<T>;
{{/each}}

/**
 * Use this method if you want to get a single property from state and a callback function for updating it of {{featureName.pascalCase}}
 * @param propertyName property of state
 */
export function useDirect{{featureName.pascalCase}}Property<
    T extends keyof {{state.stateName}}
>(propertyName: T) {
    const value = useDirect{{featureName.pascalCase}}PropertyValue(propertyName);
    const setProperty = useDirect{{featureName.pascalCase}}PropertySetProperty(propertyName as any);
    return useMemo(() => [value, setProperty], [value, setProperty]);
};

export function useNamed{{featureName.pascalCase}}StateProperty<
    T extends keyof {{state.stateName}}
>(propertyName: T) {
    return useDirect{{featureName.pascalCase}}Property<T>(propertyName);
}

/**
 * Use this method if you want to get only a single property from state of {{featureName.pascalCase}}
 * @param propertyName property of state
 */
export function useDirect{{featureName.pascalCase}}PropertyValue<
    T extends keyof {{state.stateName}}
>(propertyName: T): {{state.stateName}}[T] {
    const state = use{{featureName.pascalCase}}ReducerContextState();
    return state[propertyName];
};

export function useNamed{{featureName.pascalCase}}StatePropertyValue<
    T extends keyof {{state.stateName}}
>(propertyName: T) {
    return useDirect{{featureName.pascalCase}}PropertyValue<T>(propertyName);
}

{{#each state.properties}}
export function useDirect{{../featureName.pascalCase}}PropertySetProperty<
    T extends keyof {{../state.stateName}}
>(propertyName: T): T extends "{{name}}" ? {{../featureName.pascalCase}}SetPropertyHandler<"{{name}}"> : {{../featureName.pascalCase}}SetPropertyHandler<T>;
{{/each}}

/**
 * Use this method if you want a callback function for updating a single property of {{featureName.pascalCase}}
 * @param propertyName property of state
 */
export function useDirect{{featureName.pascalCase}}PropertySetProperty<
    T extends keyof {{state.stateName}}
>(propertyName: T) {
    const dispatch = use{{featureName.pascalCase}}ReducerContextDispatch();

    return useMemo(() => {
        switch (propertyName) {
    {{#each state.properties}}
            case "{{name}}":
                return (next: {{../state.stateName}}["{{name}}"]) =>
                    dispatch(
                        {{../actionCreators.mainActionCreatorsName}}.set{{namePascalCase}}(
                            next
                        )
                    );
    {{/each}}
            default:
                throw new Error(
                    `Unknown property. No property with name "${propertyName}" has been registered for state of feature "{{featureName.pascalCase}}".`
                );
        }
    }, [dispatch, propertyName]);
};
